// Code generated by protocol buffer compiler. Do not edit!
package emu.lunarcore.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.RepeatedMessage;
import us.hebi.quickbuf.Utf8String;

public final class GetSecretKeyInfoScRspOuterClass {
  /**
   * Protobuf type {@code GetSecretKeyInfoScRsp}
   */
  public static final class GetSecretKeyInfoScRsp extends ProtoMessage<GetSecretKeyInfoScRsp> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 retcode = 11;</code>
     */
    private int retcode;

    /**
     * <code>optional bytes idk = 1;</code>
     */
    private final RepeatedByte idk = RepeatedByte.newEmptyInstance();

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     */
    private final RepeatedMessage<SecretKey> secretKeys = RepeatedMessage.newEmptyInstance(SecretKey.getFactory());

    private GetSecretKeyInfoScRsp() {
    }

    /**
     * @return a new empty instance of {@code GetSecretKeyInfoScRsp}
     */
    public static GetSecretKeyInfoScRsp newInstance() {
      return new GetSecretKeyInfoScRsp();
    }

    /**
     * <code>optional uint32 retcode = 11;</code>
     * @return whether the retcode field is set
     */
    public boolean hasRetcode() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 retcode = 11;</code>
     * @return this
     */
    public GetSecretKeyInfoScRsp clearRetcode() {
      bitField0_ &= ~0x00000001;
      retcode = 0;
      return this;
    }

    /**
     * <code>optional uint32 retcode = 11;</code>
     * @return the retcode
     */
    public int getRetcode() {
      return retcode;
    }

    /**
     * <code>optional uint32 retcode = 11;</code>
     * @param value the retcode to set
     * @return this
     */
    public GetSecretKeyInfoScRsp setRetcode(final int value) {
      bitField0_ |= 0x00000001;
      retcode = value;
      return this;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     * @return whether the idk field is set
     */
    public boolean hasIdk() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     * @return this
     */
    public GetSecretKeyInfoScRsp clearIdk() {
      bitField0_ &= ~0x00000002;
      idk.clear();
      return this;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableIdk()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedByte getIdk() {
      return idk;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedByte getMutableIdk() {
      bitField0_ |= 0x00000002;
      return idk;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     * @param value the idk to add
     * @return this
     */
    public GetSecretKeyInfoScRsp addIdk(final byte value) {
      bitField0_ |= 0x00000002;
      idk.add(value);
      return this;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     * @param values the idk to add
     * @return this
     */
    public GetSecretKeyInfoScRsp addAllIdk(final byte... values) {
      bitField0_ |= 0x00000002;
      idk.addAll(values);
      return this;
    }

    /**
     * <code>optional bytes idk = 1;</code>
     * @param values the idk to set
     * @return this
     */
    public GetSecretKeyInfoScRsp setIdk(final byte... values) {
      bitField0_ |= 0x00000002;
      idk.copyFrom(values);
      return this;
    }

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     * @return whether the secretKeys field is set
     */
    public boolean hasSecretKeys() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     * @return this
     */
    public GetSecretKeyInfoScRsp clearSecretKeys() {
      bitField0_ &= ~0x00000004;
      secretKeys.clear();
      return this;
    }

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSecretKeys()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedMessage<SecretKey> getSecretKeys() {
      return secretKeys;
    }

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedMessage<SecretKey> getMutableSecretKeys() {
      bitField0_ |= 0x00000004;
      return secretKeys;
    }

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     * @param value the secretKeys to add
     * @return this
     */
    public GetSecretKeyInfoScRsp addSecretKeys(final SecretKey value) {
      bitField0_ |= 0x00000004;
      secretKeys.add(value);
      return this;
    }

    /**
     * <code>repeated .GetSecretKeyInfoScRsp.SecretKey secret_keys = 3;</code>
     * @param values the secretKeys to add
     * @return this
     */
    public GetSecretKeyInfoScRsp addAllSecretKeys(final SecretKey... values) {
      bitField0_ |= 0x00000004;
      secretKeys.addAll(values);
      return this;
    }

    @Override
    public GetSecretKeyInfoScRsp copyFrom(final GetSecretKeyInfoScRsp other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        retcode = other.retcode;
        idk.copyFrom(other.idk);
        secretKeys.copyFrom(other.secretKeys);
      }
      return this;
    }

    @Override
    public GetSecretKeyInfoScRsp mergeFrom(final GetSecretKeyInfoScRsp other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRetcode()) {
        setRetcode(other.retcode);
      }
      if (other.hasIdk()) {
        getMutableIdk().copyFrom(other.idk);
      }
      if (other.hasSecretKeys()) {
        getMutableSecretKeys().addAll(other.secretKeys);
      }
      return this;
    }

    @Override
    public GetSecretKeyInfoScRsp clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      retcode = 0;
      idk.clear();
      secretKeys.clear();
      return this;
    }

    @Override
    public GetSecretKeyInfoScRsp clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      idk.clear();
      secretKeys.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof GetSecretKeyInfoScRsp)) {
        return false;
      }
      GetSecretKeyInfoScRsp other = (GetSecretKeyInfoScRsp) o;
      return bitField0_ == other.bitField0_
        && (!hasRetcode() || retcode == other.retcode)
        && (!hasIdk() || idk.equals(other.idk))
        && (!hasSecretKeys() || secretKeys.equals(other.secretKeys));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(retcode);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 10);
        output.writeBytesNoTag(idk);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        for (int i = 0; i < secretKeys.length(); i++) {
          output.writeRawByte((byte) 26);
          output.writeMessageNoTag(secretKeys.get(i));
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(retcode);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeBytesSizeNoTag(idk);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += (1 * secretKeys.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(secretKeys);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public GetSecretKeyInfoScRsp mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 88: {
            // retcode
            retcode = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
          case 10: {
            // idk
            input.readBytes(idk);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // secretKeys
            tag = input.readRepeatedMessage(secretKeys, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.retcode, retcode);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeBytes(FieldNames.idk, idk);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRepeatedMessage(FieldNames.secretKeys, secretKeys);
      }
      output.endObject();
    }

    @Override
    public GetSecretKeyInfoScRsp mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1097936398: {
            if (input.isAtField(FieldNames.retcode)) {
              if (!input.trySkipNullValue()) {
                retcode = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 104112: {
            if (input.isAtField(FieldNames.idk)) {
              if (!input.trySkipNullValue()) {
                input.readBytes(idk);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1451747132:
          case -2035857885: {
            if (input.isAtField(FieldNames.secretKeys)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(secretKeys);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public GetSecretKeyInfoScRsp clone() {
      return new GetSecretKeyInfoScRsp().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static GetSecretKeyInfoScRsp parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new GetSecretKeyInfoScRsp(), data).checkInitialized();
    }

    public static GetSecretKeyInfoScRsp parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GetSecretKeyInfoScRsp(), input).checkInitialized();
    }

    public static GetSecretKeyInfoScRsp parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new GetSecretKeyInfoScRsp(), input).checkInitialized();
    }

    /**
     * @return factory for creating GetSecretKeyInfoScRsp messages
     */
    public static MessageFactory<GetSecretKeyInfoScRsp> getFactory() {
      return GetSecretKeyInfoScRspFactory.INSTANCE;
    }

    /**
     * Protobuf enum {@code SecretKeyType}
     */
    public enum SecretKeyType implements ProtoEnum<SecretKeyType> {
      /**
       * <code>SECRET_KEY_NONE = 0;</code>
       */
      SECRET_KEY_NONE("SECRET_KEY_NONE", 0),

      /**
       * <code>SECRET_KEY_SERVER_CHECK = 1;</code>
       */
      SECRET_KEY_SERVER_CHECK("SECRET_KEY_SERVER_CHECK", 1),

      /**
       * <code>SECRET_KEY_VIDEO = 2;</code>
       */
      SECRET_KEY_VIDEO("SECRET_KEY_VIDEO", 2),

      /**
       * <code>SECRET_KEY_BATTLE_TIME = 3;</code>
       */
      SECRET_KEY_BATTLE_TIME("SECRET_KEY_BATTLE_TIME", 3);

      /**
       * <code>SECRET_KEY_NONE = 0;</code>
       */
      public static final int SECRET_KEY_NONE_VALUE = 0;

      /**
       * <code>SECRET_KEY_SERVER_CHECK = 1;</code>
       */
      public static final int SECRET_KEY_SERVER_CHECK_VALUE = 1;

      /**
       * <code>SECRET_KEY_VIDEO = 2;</code>
       */
      public static final int SECRET_KEY_VIDEO_VALUE = 2;

      /**
       * <code>SECRET_KEY_BATTLE_TIME = 3;</code>
       */
      public static final int SECRET_KEY_BATTLE_TIME_VALUE = 3;

      private final String name;

      private final int number;

      private SecretKeyType(String name, int number) {
        this.name = name;
        this.number = number;
      }

      /**
       * @return the string representation of enum entry
       */
      @Override
      public String getName() {
        return name;
      }

      /**
       * @return the numeric wire value of this enum entry
       */
      @Override
      public int getNumber() {
        return number;
      }

      /**
       * @return a converter that maps between this enum's numeric and text representations
       */
      public static ProtoEnum.EnumConverter<SecretKeyType> converter() {
        return SecretKeyTypeConverter.INSTANCE;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value, or null if unknown.
       */
      public static SecretKeyType forNumber(int value) {
        return SecretKeyTypeConverter.INSTANCE.forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @param other Fallback value in case the value is not known.
       * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
       */
      public static SecretKeyType forNumberOr(int number, SecretKeyType other) {
        SecretKeyType value = forNumber(number);
        return value == null ? other : value;
      }

      enum SecretKeyTypeConverter implements ProtoEnum.EnumConverter<SecretKeyType> {
        INSTANCE;

        private static final SecretKeyType[] lookup = new SecretKeyType[4];

        static {
          lookup[0] = SECRET_KEY_NONE;
          lookup[1] = SECRET_KEY_SERVER_CHECK;
          lookup[2] = SECRET_KEY_VIDEO;
          lookup[3] = SECRET_KEY_BATTLE_TIME;
        }

        @Override
        public final SecretKeyType forNumber(final int value) {
          if (value >= 0 && value < lookup.length) {
            return lookup[value];
          }
          return null;
        }

        @Override
        public final SecretKeyType forName(final CharSequence value) {
          switch (value.length()) {
            case 15: {
              if (ProtoUtil.isEqual("SECRET_KEY_NONE", value)) {
                return SECRET_KEY_NONE;
              }
              break;
            }
            case 16: {
              if (ProtoUtil.isEqual("SECRET_KEY_VIDEO", value)) {
                return SECRET_KEY_VIDEO;
              }
              break;
            }
            case 22: {
              if (ProtoUtil.isEqual("SECRET_KEY_BATTLE_TIME", value)) {
                return SECRET_KEY_BATTLE_TIME;
              }
              break;
            }
            case 23: {
              if (ProtoUtil.isEqual("SECRET_KEY_SERVER_CHECK", value)) {
                return SECRET_KEY_SERVER_CHECK;
              }
              break;
            }
          }
          return null;
        }
      }
    }

    /**
     * Protobuf type {@code SecretKey}
     */
    public static final class SecretKey extends ProtoMessage<SecretKey> implements Cloneable {
      private static final long serialVersionUID = 0L;

      /**
       * <code>optional .GetSecretKeyInfoScRsp.SecretKeyType type = 7;</code>
       */
      private int type;

      /**
       * <code>optional string secret_key = 14;</code>
       */
      private final Utf8String secretKey = Utf8String.newEmptyInstance();

      private SecretKey() {
      }

      /**
       * @return a new empty instance of {@code SecretKey}
       */
      public static SecretKey newInstance() {
        return new SecretKey();
      }

      /**
       * <code>optional .GetSecretKeyInfoScRsp.SecretKeyType type = 7;</code>
       * @return whether the type field is set
       */
      public boolean hasType() {
        return (bitField0_ & 0x00000001) != 0;
      }

      /**
       * <code>optional .GetSecretKeyInfoScRsp.SecretKeyType type = 7;</code>
       * @return this
       */
      public SecretKey clearType() {
        bitField0_ &= ~0x00000001;
        type = 0;
        return this;
      }

      /**
       * <code>optional .GetSecretKeyInfoScRsp.SecretKeyType type = 7;</code>
       * @return the type
       */
      public SecretKeyType getType() {
        return SecretKeyType.forNumber(type);
      }

      /**
       * Gets the value of the internal enum store. The result is
       * equivalent to {@link SecretKey#getType()}.getNumber().
       *
       * @return numeric wire representation
       */
      public int getTypeValue() {
        return type;
      }

      /**
       * Sets the value of the internal enum store. This does not
       * do any validity checks, so be sure to use appropriate value
       * constants from {@link SecretKeyType}. Setting an invalid value
       * can cause {@link SecretKey#getType()} to return null
       *
       * @param value the numeric wire value to set
       * @return this
       */
      public SecretKey setTypeValue(final int value) {
        bitField0_ |= 0x00000001;
        type = value;
        return this;
      }

      /**
       * <code>optional .GetSecretKeyInfoScRsp.SecretKeyType type = 7;</code>
       * @param value the type to set
       * @return this
       */
      public SecretKey setType(final SecretKeyType value) {
        bitField0_ |= 0x00000001;
        type = value.getNumber();
        return this;
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @return whether the secretKey field is set
       */
      public boolean hasSecretKey() {
        return (bitField0_ & 0x00000002) != 0;
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @return this
       */
      public SecretKey clearSecretKey() {
        bitField0_ &= ~0x00000002;
        secretKey.clear();
        return this;
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @return the secretKey
       */
      public String getSecretKey() {
        return secretKey.getString();
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @return internal {@code Utf8String} representation of secretKey for reading
       */
      public Utf8String getSecretKeyBytes() {
        return this.secretKey;
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @return internal {@code Utf8String} representation of secretKey for modifications
       */
      public Utf8String getMutableSecretKeyBytes() {
        bitField0_ |= 0x00000002;
        return this.secretKey;
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @param value the secretKey to set
       * @return this
       */
      public SecretKey setSecretKey(final CharSequence value) {
        bitField0_ |= 0x00000002;
        secretKey.copyFrom(value);
        return this;
      }

      /**
       * <code>optional string secret_key = 14;</code>
       * @param value the secretKey to set
       * @return this
       */
      public SecretKey setSecretKey(final Utf8String value) {
        bitField0_ |= 0x00000002;
        secretKey.copyFrom(value);
        return this;
      }

      @Override
      public SecretKey copyFrom(final SecretKey other) {
        cachedSize = other.cachedSize;
        if ((bitField0_ | other.bitField0_) != 0) {
          bitField0_ = other.bitField0_;
          type = other.type;
          secretKey.copyFrom(other.secretKey);
        }
        return this;
      }

      @Override
      public SecretKey mergeFrom(final SecretKey other) {
        if (other.isEmpty()) {
          return this;
        }
        cachedSize = -1;
        if (other.hasType()) {
          setTypeValue(other.type);
        }
        if (other.hasSecretKey()) {
          getMutableSecretKeyBytes().copyFrom(other.secretKey);
        }
        return this;
      }

      @Override
      public SecretKey clear() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        type = 0;
        secretKey.clear();
        return this;
      }

      @Override
      public SecretKey clearQuick() {
        if (isEmpty()) {
          return this;
        }
        cachedSize = -1;
        bitField0_ = 0;
        secretKey.clear();
        return this;
      }

      @Override
      public boolean equals(Object o) {
        if (o == this) {
          return true;
        }
        if (!(o instanceof SecretKey)) {
          return false;
        }
        SecretKey other = (SecretKey) o;
        return bitField0_ == other.bitField0_
          && (!hasType() || type == other.type)
          && (!hasSecretKey() || secretKey.equals(other.secretKey));
      }

      @Override
      public void writeTo(final ProtoSink output) throws IOException {
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeRawByte((byte) 56);
          output.writeEnumNoTag(type);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeRawByte((byte) 114);
          output.writeStringNoTag(secretKey);
        }
      }

      @Override
      protected int computeSerializedSize() {
        int size = 0;
        if ((bitField0_ & 0x00000001) != 0) {
          size += 1 + ProtoSink.computeEnumSizeNoTag(type);
        }
        if ((bitField0_ & 0x00000002) != 0) {
          size += 1 + ProtoSink.computeStringSizeNoTag(secretKey);
        }
        return size;
      }

      @Override
      @SuppressWarnings("fallthrough")
      public SecretKey mergeFrom(final ProtoSource input) throws IOException {
        // Enabled Fall-Through Optimization (QuickBuffers)
        int tag = input.readTag();
        while (true) {
          switch (tag) {
            case 56: {
              // type
              final int value = input.readInt32();
              if (SecretKeyType.forNumber(value) != null) {
                type = value;
                bitField0_ |= 0x00000001;
              }
              tag = input.readTag();
              if (tag != 114) {
                break;
              }
            }
            case 114: {
              // secretKey
              input.readString(secretKey);
              bitField0_ |= 0x00000002;
              tag = input.readTag();
              if (tag != 0) {
                break;
              }
            }
            case 0: {
              return this;
            }
            default: {
              if (!input.skipField(tag)) {
                return this;
              }
              tag = input.readTag();
              break;
            }
          }
        }
      }

      @Override
      public void writeTo(final JsonSink output) throws IOException {
        output.beginObject();
        if ((bitField0_ & 0x00000001) != 0) {
          output.writeEnum(FieldNames.type, type, SecretKeyType.converter());
        }
        if ((bitField0_ & 0x00000002) != 0) {
          output.writeString(FieldNames.secretKey, secretKey);
        }
        output.endObject();
      }

      @Override
      public SecretKey mergeFrom(final JsonSource input) throws IOException {
        if (!input.beginObject()) {
          return this;
        }
        while (!input.isAtEnd()) {
          switch (input.readFieldHash()) {
            case 3575610: {
              if (input.isAtField(FieldNames.type)) {
                if (!input.trySkipNullValue()) {
                  final SecretKeyType value = input.readEnum(SecretKeyType.converter());
                  if (value != null) {
                    type = value.getNumber();
                    bitField0_ |= 0x00000001;
                  } else {
                    input.skipUnknownEnumValue();
                  }
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            case -739567217:
            case -1451146160: {
              if (input.isAtField(FieldNames.secretKey)) {
                if (!input.trySkipNullValue()) {
                  input.readString(secretKey);
                  bitField0_ |= 0x00000002;
                }
              } else {
                input.skipUnknownField();
              }
              break;
            }
            default: {
              input.skipUnknownField();
              break;
            }
          }
        }
        input.endObject();
        return this;
      }

      @Override
      public SecretKey clone() {
        return new SecretKey().copyFrom(this);
      }

      @Override
      public boolean isEmpty() {
        return ((bitField0_) == 0);
      }

      public static SecretKey parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new SecretKey(), data).checkInitialized();
      }

      public static SecretKey parseFrom(final ProtoSource input) throws IOException {
        return ProtoMessage.mergeFrom(new SecretKey(), input).checkInitialized();
      }

      public static SecretKey parseFrom(final JsonSource input) throws IOException {
        return ProtoMessage.mergeFrom(new SecretKey(), input).checkInitialized();
      }

      /**
       * @return factory for creating SecretKey messages
       */
      public static MessageFactory<SecretKey> getFactory() {
        return SecretKeyFactory.INSTANCE;
      }

      private enum SecretKeyFactory implements MessageFactory<SecretKey> {
        INSTANCE;

        @Override
        public SecretKey create() {
          return SecretKey.newInstance();
        }
      }

      /**
       * Contains name constants used for serializing JSON
       */
      static class FieldNames {
        static final FieldName type = FieldName.forField("type");

        static final FieldName secretKey = FieldName.forField("secretKey", "secret_key");
      }
    }

    private enum GetSecretKeyInfoScRspFactory implements MessageFactory<GetSecretKeyInfoScRsp> {
      INSTANCE;

      @Override
      public GetSecretKeyInfoScRsp create() {
        return GetSecretKeyInfoScRsp.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName retcode = FieldName.forField("retcode");

      static final FieldName idk = FieldName.forField("idk");

      static final FieldName secretKeys = FieldName.forField("secretKeys", "secret_keys");
    }
  }
}
